#include <assert.h>
extern int printf(const char*, ...);

char arr[1];
static void f (void){}
void (*fp)(void) = f;
void call_fp()
{
    (fp?f:f)();
    (fp?fp:fp)();
    (fp?fp:&f)();
    (fp?&f:fp)();
    (fp?&f:&f)();
    _Generic(0?arr:arr, char*: (void)0);
    _Generic(0?&arr[0]:arr, char*: (void)0);
    _Generic(0?arr:&arr[0], char*: (void)0);
    _Generic(1?arr:arr, char*: (void)0);
    _Generic(1?&arr[0]:arr, char*: (void)0);
    _Generic(1?arr:&arr[0], char*: (void)0);
    _Generic((__typeof(1?f:f)*){0}, void (**)(void): (void)0);
    (fp?&f:f)();
    (fp?f:&f)();
    _Generic((__typeof(fp?0L:(void)0)*){0}, void*: (void)0);

    /* The following line causes a warning */
    void *xx = fp?f:1;
}

struct condstruct {
    int i;
};

static int getme(struct condstruct* s, int i)
{
    int i1 = (i != 0 ? 0 : s)->i;
    int i2 = (i == 0 ? s : 0)->i;
    int i3 = (i != 0 ? (void*)0 : s)->i;
    int i4 = (i == 0 ? s : (void*)0)->i;
    return i1 + i2 + i3 + i4;
}

int someglobal;

void constantcond(void)
{
  /* This was broken by 8227db3a2, it saved/restored the CODE_OFF state
     during the expression and that bled out to the outer one disabling
     codegen for if-body.  */
  if (( (someglobal ? 0 : 0) ? 8 : 9))
    printf("okay\n");
}

unsigned short tf_4_var_2 = 29886;
const unsigned short tf_4_var_34 = 54077;
const unsigned short tf_4_var_86 = 1129;
long int tf_4_var_98 = -4448775496354969734L;

unsigned short tf_4_array_8 [9] =
    {52593, 34626, 28127, 8124, 11473, 14634, 8370, 31153, 31060};
unsigned short tf_4_array_2 [6] =
    {7493, 64504, 22566, 54931, 44752, 18026};
unsigned short tf_4_array_3 [9] =
    {22671, 46595, 24007, 22460, 12020, 19732, 46148, 3906, 26139};
unsigned short tf_4_array_7 [9] =
    {24530, 26236, 61122, 9019, 26099, 31028, 1078, 27042, 36756};
unsigned short tf_4_array_4 [9] =
    {32711, 2853, 55531, 52731, 6621, 38797, 23543, 64627, 55640};

long int tf_4_var_132 = -6396431410421938408L;

static void tst_yarpgen(void)
{
    /* generated by yarpgen */
    tf_4_var_132 = (long int) (((unsigned long long int) (((((((int) (tf_4_var_86)) && ((int) (tf_4_array_8 [0]))) ? (((int) (tf_4_var_2)) || ((int) (8))) : (((int) (tf_4_array_2 [0])) || (-4096)))) || ((((int) (tf_4_array_3 [6])) || ((int) (tf_4_var_34))) && (((int) (tf_4_array_3 [7])) || ((int) (tf_4_var_98))))) % ((+((int) ((unsigned short) (-6)))) && ((((int) (tf_4_array_7 [5])) & ((int) (tf_4_array_7 [1]))) | (((int) (tf_4_array_4 [0])) & ((int) (tf_4_array_4 [0]))))))) <= (((unsigned long long int) ((int) ((unsigned short) (((7192886880476152731ULL) * (7192886880476152731ULL)) * ((unsigned long long int) (((-9223372036854775807L - 1L)) * ((long int) ((int) (0))))))))) * (((unsigned long long int) (((-6) * ((int) (3))) * (-((int) (4))))) * (((8ULL) * (4ULL)) * ((unsigned long long int) (((long int) (-6)) * (-3L)))))));
    printf("%ld\n", tf_4_var_132);
}

int main()
{
   int Count;

   for (Count = 0; Count < 10; Count++)
   {
      printf("%d\n", (Count < 5) ? (Count*Count) : (Count * 3));
   }

   {
    int c = 0;
    #define ASSERT(X) assert(X)
    static struct stru { int x; } a={'A'},b={'B'};
    static const struct stru2 { int x; } d = { 'D' };
    ASSERT('A'==(*(1?&a:&b)).x);
    ASSERT('A'==(1?a:b).x);
    ASSERT('A'==(c?b:a).x);
    ASSERT('A'==(0?b:a).x);
    c=1;
    ASSERT('A'==(c?a:b).x);
    ASSERT(sizeof(int)    == sizeof(0 ? 'a' : c));
    ASSERT(sizeof(double) == sizeof(0 ? 'a' : 1.0));
    ASSERT(sizeof(double) == sizeof(0 ? 0.0 : 'a'));
    ASSERT(sizeof(float)  == sizeof(0 ? 'a' : 1.0f));
    ASSERT(sizeof(double) == sizeof(0 ? 0.0 : 1.0f));
    struct condstruct cs = { 38 };
    printf("%d\n", getme(&cs, 0));

    // the following lines contain type mismatch errors in every ternary expression
    //printf("comparing double with pointer : size = %d\n", sizeof(0 ? &c : 0.0));
    //printf("'%c' <> '%c'\n", (0 ? a : d).x, (1 ? a : d).x);
    //0 ? a : 0.0;
   }

   constantcond();

   tst_yarpgen();

   return 0;
}

/* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
